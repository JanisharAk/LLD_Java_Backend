Builder Design Pattern:-
      Defin:- The Builder Design Pattern is a creational design pattern used to
              construct complex objects step by step. It separates object construction
              from its representation, allowing for more controlled and flexible object
              creation.


Why Use Builder Pattern?
     âœ… Handles complex object creation with many optional parameters.
     âœ… Avoids telescoping constructor (multiple overloaded constructors).
     âœ… Increases code readability and maintainability.
     âœ… Ensures immutability (final fields, fluent API).

When to Use Builder Pattern?
     âœ… When dealing with complex objects with multiple optional parameters.
     âœ… When using immutable objects.
     âœ… When constructor overloading leads to telescoping constructors.

     ğŸš€ Real-World Use Cases:
     âœ”ï¸ Creating REST API Request objects (like in Retrofit or HttpClient).
     âœ”ï¸ Configuring Database Connection objects.
     âœ”ï¸ Building JSON or XML responses.


     ==========================================================

Ways to Break the Builder Pattern & Their Solutions?.

    1. Allowing Object Modification After Creation (Mutability Issue)
         Problem:
         âœ…  If the constructed object allows modification after creation, it
             defeats the purpose of immutability.

         Solution:
         âœ…  Mark fields as final and remove setters to ensure immutability.

    2. Allowing Partially Built Objects (Incomplete Object Problem)
         Problem:
         âœ…  A builder may allow creating an incomplete object, leading to
             NullPointerExceptions at runtime.

         Solution:
         âœ…  Validate mandatory fields inside the build() method.

    3. Exposing the Builderâ€™s Reference (Leaking this Reference)
         Problem:
         âœ…   Returning the builder instance before construction is complete can
              lead to unexpected behavior.

         Solution:
         âœ…   Ensure the object is fully constructed before exposing it.
         âœ…   Only expose the build() method as the final step.

    4. Thread Safety Issues (Concurrent Modifications on Builder)
         Problem:
         âœ…   If a builder is shared across multiple threads, it can cause race
              conditions and inconsistent object states.

         Solution:
         âœ…   Avoid sharing the builder between threads.
         âœ…   Use ThreadLocal if needed for multithreading.
         âœ…   Use synchronization if a builder must be shared.


    5. Creating an Inconsistent Object State (Breaking Encapsulation)
         Problem:
         âœ…   A builder may allow invalid field combinations, leading to an inconsistent
               object state

         Solution:
         âœ…   Add business logic validation in the build() method.

    6. Forgetting to Clone the Builder Fields (Aliasing Issue)
         Problem:
         âœ…   Mutable objects (like lists, maps, or collections) inside the builder may
              be shared, leading to unintended side effects.

         âœ…   Always create a defensive copy of mutable fields.             .