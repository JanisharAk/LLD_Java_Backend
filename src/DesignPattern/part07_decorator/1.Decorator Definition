Decorator Design Pattern:-
Definition:-
  âœ… The Decorator Design Pattern is a structural design pattern that allows behavior to
      be added to individual objects, either statically or dynamically, without modifying
      their class definition. It follows the Open-Closed Principle (OCP), enabling extension
      of functionality without altering existing code.

Key Concepts of the Decorator Pattern
  âœ… Component Interface: Defines the common behavior for both concrete components and
     decorators.
  âœ… Concrete Component: The base object to which decorators add functionalities.
  âœ… Decorator Class: Wraps the concrete component and adds new behavior dynamically.
  âœ… Concrete Decorators: Extend the decorator class and add new functionalities.


Why Use the Decorator Pattern?
  âœ… Extensibility â€“ New functionalities can be added without modifying existing code.
  âœ… Flexible Composition â€“ Multiple decorators can be combined dynamically.
  âœ… Single Responsibility Principle (SRP) â€“ Each decorator has a well-defined responsibility.
  âœ… Avoids Subclass Explosion â€“ Prevents an excessive number of subclasses compared to an
     inheritance-based approach.

When to Use the Decorator Pattern?
  ðŸ”¹ When you need to add functionality dynamically to an object at runtime.
  ðŸ”¹ When subclassing is not feasible due to an excessive number of variations.
  ðŸ”¹ When you want to follow Open-Closed Principle (OCP) and Single Responsibility Principle (SRP).

Real-World Examples
  âœ… Java I/O Streams (BufferedReader, InputStreamReader)
  âœ… GUI Components (JButton with different look and feel decorators)
  âœ… Logging Frameworks (e.g., adding timestamps, log levels dynamically)



   ======================================================

          Ways to Break the Decorator Design Pattern & Their Solutions


1. Forgetting to Call the Wrapped Componentâ€™s Methods
Problem:
  âœ… A decorator should always call the wrapped componentâ€™s methods before adding its own behavior.
  âœ… If a decorator forgets to delegate the method call, the chain breaks, leading to missing
     functionalities.

Solution:
  âœ… Always Call the Wrapped Objectâ€™s Methods

2. Creating Circular Dependencies
Problem:
  âœ… A decorator should not wrap itself or form a cycle, which leads to infinite loops or
     StackOverflowErrors.
Solution:
  âœ… Use Dependency Injection Correctly.

3. Not Providing a Base Component
Problem:
  âœ… The decorator pattern needs a base concrete implementation.
  âœ… If no concrete class (like OrangeCone) is provided, instantiation fails

Solution:
  âœ… Use a Base Component

